import os
import ruamel.yaml
import graphml_converter

GENERATED_DIRECTORY = os.path.join(os.getcwd(),"esame","generated")
TEMPLATES_DIRECTORY = os.path.join(os.getcwd(),"esame","templates","esame")

v = graphml_converter.node_edges()
e = graphml_converter.node_arrow()

nodes_values = {}
numero_nodi, numero_archi = graphml_converter.numero_node_edges()
coordinate_nodi = graphml_converter.node_position()
colori_nodi = graphml_converter.node_color()
tag_nodi = graphml_converter.node_tag()

yaml = ruamel.yaml.YAML()
with open('simulazione_esame/esercizio_3/modo_browser/graphs_mst.yaml') as cn:
    data = yaml.load(cn)
    node_color = data['nodecol_action'][0]
    initial_nodes_color = data['nodecol_action'][1]
    background_col = initial_nodes_color
    initial_nodes_color = "'"+initial_nodes_color+"'"

    edge_color = data['edgecol_action'][0]
    edge_color_starting = data['edgecol_action'][1]
    edge_color_starting = "'"+edge_color_starting+"'"

def assign_coords(v):
    for node,count in zip(v,range(numero_nodi)):
        nodes_values[node] = {}
        nodes_values[node]['x'] = coordinate_nodi[count][0]
        nodes_values[node]['y'] = coordinate_nodi[count][1]
        nodes_values[node]['color'] = colori_nodi[count]
        nodes_values[node]['tag'] = tag_nodi[count]

def write_yaml():
    yaml = ruamel.yaml.YAML()
    graph_edges = graphml_converter.edge_string() #grafo senza l'informazione arco puntato o meno
    with open('simulazione_esame/esercizio_3/modo_browser/graphs_mst.yaml') as fp:
        data = yaml.load(fp)

    data['instance']['n'] = numero_nodi
    data['instance']['m'] = numero_archi
    data['instance']['edges'] = graph_edges

    with open('simulazione_esame/esercizio_3/modo_browser/graphs_mst.yaml', 'w') as fp:
        yaml.dump(data, fp)

def init_graph_html():
    assign_coords(v)
    txt = ""
    for node in v:
        txt += f"<div class='node' id='{node}' style='top:{nodes_values[node]['y']}px;left:{nodes_values[node]['x']}px; background: {background_col};border: thin solid black' onclick='javascript:change(this.id);'>\n"#{node}</div>\n"
        txt += f"<label id='{node}-label-char' style='position: absolute; top:0%;left:25%;'> {node}</label>\n"
        txt += f"<label id='{node}-label' style='font-size: 14px; position: absolute; top:75%;left:0%;'> {nodes_values[node]['tag']}</label>\n"
        txt += "</div>\n"
    txt += "<script>\n"
    txt += "  $('.node').draggable();\n"
    txt += "  var _lines = new Array(); //This array will store all lines (option)\n"
    txt += "  var _canvas = document.createElement('canvas');\n"
    txt += "  var _ctx;\n"
    txt += "  var ele1 , ele2, f=0;\n"
    txt += "  var lineindex =0;\n"
    txt += "  var linemap = {};\n"
    txt += "  var _left = new Object(); //This will store _left elements offset\n"
    txt += "  var _right = new Object(); //This will store _right elements offset\n"
    txt += "  var _color='coral';\n"
    txt += "  var _dash;\n"
    txt += "  var _id;\n"
    txt += "  var clientrectleft\n"
    txt += "  var clientrectright\n"
    txt += "  var leftnodeoffsetx\n"
    txt += "  var leftnodeoffsety\n"
    txt += "  var rightnodeoffsetx\n"
    txt += "  var rightnodeoffsety\n"
    txt += "  var dax\n"
    txt += "  var day\n"
    txt += "  var dangle\n"
    txt += "  var rightx\n"
    txt += "  var righty\n"
    txt += "  var leftx\n"
    txt += "  var lefty\n"
    txt += "  var _error =false;\n"
    txt += "    var connect = function() {\n"
    txt += "      var _me = this;\n"
    txt += "      //Initialize Canvas object\n"
    txt += "      _canvas.id = 'cav1';\n"
    txt += "      _canvas.width = document.body.clientWidth;\n"
    txt += "      _canvas.height = document.body.clientHeight;\n"
    txt += "      document.body.appendChild(_canvas)\n"
    txt += "      _ctx = _canvas.getContext('2d');\n"
    txt += "      this.drawLine = function(option) {\n"
    txt += "        //It will push line to array.\n"
    txt += "        linemap[`${option.left_node}${option.right_node}`] = _lines.length;\n"
    txt += "        _lines.push(option);\n"
    txt += "        this.connect(option);\n"
    txt += "      };\n"
    txt += "  this.kruskalize =function (_cl = 'rgb(0,0,0,0.08)')  {\n"
    txt += "    for ( line of _lines) {\n"
    txt += "      line.col = _cl;\n"
    txt += "    }\n"
    txt += "  }\n"
    txt += "      this.changecolor = function (starting , ending , assignedcolor) {\n"
    txt += "    if (linemap[`${starting}${ending}`] != undefined)  {\n"
    txt += "       let  targg = parseInt(linemap[`${starting}${ending}`]);\n"
    txt += "       console.log(targg , starting , ending  , assignedcolor)\n"
    txt += "      _lines[targg].col =assignedcolor;\n"
    txt += "    }\n"
    txt += "    else {\n"
    txt += "      let targg = parseInt(linemap[`${ending}${starting}`]);\n"
    txt += "      console.log(targg , starting , ending  , assignedcolor)\n"
    txt += "      _lines[targg].col =assignedcolor;\n"
    txt += "    }\n"
    txt += "      this.redrawLines();\n"
    txt += "      }\n"
    txt += "      this.dl = function(one , two) {\n"
    txt += "        for (var y = 0 ; y < _lines.length ; ++y) {\n"
    txt += "   if ((_lines[y].left_node) == one &&  (_lines[y].right_node) == two) {\n"
    txt += "    _lines.splice(y,1);\n"
    txt += "   }\n"
    txt += "        }\n"
    txt += "      };\n"
    txt += "      //This Function is used to connect two different div with a dotted line.\n"
    txt += "     this.connect = async function(option) {\n"
    txt += "      if ( option.left_node == undefined || option.left_node == 'null' || option.right_node == undefined || option.right_node == 'null'  ) {\n"
    txt += "        return;\n"
    txt += "      }\n"
    txt += "            //To decide colour of the line\n"
    txt += "                _color = option.col || 'coral';\n"
    txt += "                _ctx.font = '30px Segoe UI';\n"
    txt += "            //To decide style of the line. dotted or solid\n"
    txt += "            switch (option.style) {\n"
    txt += "              case 'dashed':\n"
    txt += "                _dash = [4, 2];\n"
    txt += "                break;\n"
    txt += "              case 'solid':\n"
    txt += "                _dash = [0, 0];\n"
    txt += "                break;\n"
    txt += "              case 'dotted':\n"
    txt += "                _dash = [2, 2];\n"
    txt += "                break;\n"
    txt += "              default:\n"
    txt += "                _dash = [0, 0];\n"
    txt += "                break;\n"
    txt += "            }\n"
    txt += "            _ctx.setLineDash(_dash);\n"
    txt += "            //If left_node is actually right side, following code will switch elements.\n"
    txt += "               _left_node = document.getElementById(option.left_node);\n"
    txt += "               _right_node = document.getElementById(option.right_node);\n"
    txt += "               if (_left_node == null || _right_node == null) {return;}\n"
    txt += "               clientrectleft = _left_node.getBoundingClientRect();\n"
    txt += "               clientrectright = _right_node.getBoundingClientRect();\n"
    txt += "               leftnodeoffsetx = clientrectleft.left +document.documentElement.scrollLeft;\n"
    txt += "               leftnodeoffsety = clientrectleft.top +document.documentElement.scrollTop;\n"
    txt += "               rightnodeoffsetx = clientrectright.left +document.documentElement.scrollLeft;\n"
    txt += "               rightnodeoffsety = clientrectright.top +document.documentElement.scrollTop;\n"
    txt += "               dax = (rightnodeoffsetx+ _right_node.offsetHeight/2) - (leftnodeoffsetx+ _left_node.offsetWidth/2);\n"
    txt += "               day = (rightnodeoffsety+ _right_node.offsetHeight/2) - (leftnodeoffsety+ _left_node.offsetHeight/2);\n"
    txt += "               dangle = Math.atan2(day ,dax);\n"
    txt += "               rightx = (_right_node.offsetWidth/2) * Math.cos(135+dangle) + (rightnodeoffsetx+ _right_node.offsetWidth/2) ;\n"
    txt += "               righty  = (_right_node.offsetHeight/2) * Math.sin(135+dangle) + (rightnodeoffsety + (_right_node.offsetHeight / 2)) ;\n"
    txt += "               leftx = (_left_node.offsetWidth/2) * Math.cos(.05+dangle) + (leftnodeoffsetx+ _left_node.offsetWidth/2) ;\n"
    txt += "               lefty  = (_left_node.offsetHeight/2) * Math.sin(.05+dangle) + (leftnodeoffsety + (_left_node.offsetHeight / 2)) ;\n"
    txt += "              //Get Left point and Right Point\n"
    txt += "              _left.x = leftx\n"
    txt += "              _left.y = lefty\n"
    txt += "              _right.x = rightx\n"
    txt += "              _right.y = righty\n"
    txt += "                ele1_x = _left.x;\n"
    txt += "                ele1_y = _left.y;\n"
    txt += "                ele2_x = _right.x;\n"
    txt += "                ele2_y = _right.y;\n"
    txt += "                if (option.text == -13234214325) {\n"
    txt += "                  option.text = '';\n"
    txt += "                }\n"
    txt += "                _ctx.beginPath(); \n"
    txt += "              if (option.ltype == '') {\n"
    txt += "                  _ctx.moveTo(_left.x, _left.y );\n"
    txt += "                  _ctx.lineTo((_right.x), (_right.y));\n"
    txt += "              }\n"
    txt += "              _ctx.lineWidth = option.width || 2;\n"
    txt += "              _ctx.strokeStyle = _color;\n"
    txt += "     if (option.ltype == 'curve') {\n"
    txt += "        _ctx.P1X = ele1_x;\n"
    txt += "        _ctx.P1Y = ele1_y;\n"
    txt += "        _ctx.P2X = ele2_x;\n"
    txt += "        _ctx.P2Y = ele2_y;\n"
    txt += "        _ctx.moveTo(ele1_x, ele1_y);\n"
                    # central point of the bezier curve
    txt += "        _ctx.P3X = (_ctx.P1X + _ctx.P2X)/2;\n"
    txt += "        _ctx.P3Y = (_ctx.P1Y + _ctx.P2Y)/2;\n"
    txt += "        _ctx.DistanceX = Math.abs(_ctx.P2X - _ctx.P1X);\n"
    txt += "        _ctx.DistanceY = Math.abs(_ctx.P2Y - _ctx.P1Y);\n"
    txt += "        if (_ctx.DistanceX >= _ctx.DistanceY){\n"
    txt += "            if (_ctx.P1Y<_ctx.P2Y){\n"
    txt += "                _ctx.P3Y = _ctx.P3Y + (Math.log(_ctx.DistanceX)/Math.log(2))*5;\n"
    txt += "            }else{\n"
    txt += "                _ctx.P3Y = _ctx.P3Y - (Math.log(_ctx.DistanceX)/Math.log(2))*5;\n"
    txt += "            }\n"
    txt += "        }else{\n"
    txt += "            if (_ctx.P1X<_ctx.P2X){\n"
    txt += "                _ctx.P3X = _ctx.P3X - (Math.log(_ctx.DistanceY)/Math.log(2))*5;\n"
    txt += "            }else{\n"
    txt += "                _ctx.P3X = _ctx.P3X - (Math.log(_ctx.DistanceY)/Math.log(2))*5;\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += "        _ctx.bezierCurveTo(_ctx.P3X, _ctx.P3Y, _ctx.P3X, _ctx.P3Y, ele2_x, ele2_y);\n"
    txt += "        _ctx.stroke();\n"
    txt += "       }\n"
    txt += "     if (option.gtype == 'arrow') {\n"
    txt += "              let headlen = 16; // length of head in pixels\n"
    txt += "              if (option.ltype == 'curve') {\n"
    txt += "                var dx = Number(ele2_x) - Number(_ctx.P3X);\n"
    txt += "                var dy = ele2_y - _ctx.P3Y;\n"
    txt += "              } else {\n"
    txt += "                var dx = Number(ele2_x) - Number(ele1_x);\n"
    txt += "                var dy = ele2_y - ele1_y;\n"
    txt += "              }\n"
    txt += "              let angle = Math.atan2(dy, dx);\n"
    txt += "              _ctx.moveTo(ele2_x,  ele2_y);\n"
    txt += "              _ctx.lineTo(ele2_x - headlen * Math.cos(angle - Math.PI / 6),  ele2_y - headlen * Math.sin(angle - Math.PI / 6));\n"
    txt += "              _ctx.moveTo(ele2_x,  ele2_y);\n"
    txt += "              _ctx.lineTo(ele2_x - headlen * Math.cos(angle + Math.PI / 6),  ele2_y - headlen * Math.sin(angle + Math.PI / 6));\n"
    txt += "            }\n"
    txt += "     if (option.gtype == 'bidirectional') {\n"
    txt += "              let headlen = 16; // length   of    head in pixels;\n"
    txt += "              if (option.ltype == 'curve') {\n"
    txt += "                var dx = Number(ele1_x) - Number(_ctx.P3X);\n"
    txt += "                var dy = ele1_y - _ctx.P3Y;\n"
    txt += "              } else {\n"
    txt += "                var dx = Number(ele1_x) - Number(ele2_x);\n"
    txt += "                var dy = ele1_y - ele2_y;\n"
    txt += "              }\n"
    txt += "              let angle = Math.atan2(dy, dx);\n"
    txt += "              _ctx.moveTo(ele1_x, ele1_y);\n"
    txt += "              _ctx.lineTo(ele1_x - headlen * Math.cos(angle - Math.PI / 6), ele1_y - headlen * Math.sin(angle - Math.PI / 6));\n"
    txt += "              _ctx.moveTo(ele1_x, ele1_y);\n"
    txt += "              _ctx.lineTo(ele1_x - headlen * Math.cos(angle + Math.PI / 6), ele1_y - headlen * Math.sin(angle + Math.PI / 6));\n"
    txt += "              if (option.ltype == 'curve') {\n"
    txt += "                var dx = Number(ele2_x) - Number(_ctx.P3X);\n"
    txt += "                var dy = ele2_y - _ctx.P3Y;\n"
    txt += "              } else {\n"
    txt += "                var dx = Number(ele2_x) - Number(ele1_x);\n"
    txt += "                var dy = ele2_y - ele1_y;\n"
    txt += "              }\n"
    txt += "              let firstangle = Math.atan2(dy, dx);\n"
    txt += "              _ctx.moveTo(ele2_x, ele2_y);\n"
    txt += "              _ctx.lineTo(ele2_x - headlen * Math.cos(firstangle - Math.PI / 6), ele2_y - headlen * Math.sin(firstangle - Math.PI / 6));\n"
    txt += "              _ctx.moveTo(ele2_x, ele2_y);\n"
    txt += "              _ctx.lineTo(ele2_x - headlen * Math.cos(firstangle + Math.PI / 6), ele2_y - headlen * Math.sin(firstangle + Math.PI / 6));\n"
    txt += "            }\n"
    txt += "              _ctx.stroke();\n"
    txt += "  f = 0;\n"
    txt += "              _ctx.font = 'bold 1.1em Segoe ui';\n"
    txt += "              _ctx.fillText(option.text,(_right.x +_left.x)/2-15 ,( _right.y + _left.y)/2-15);\n"
    txt += "            //option.resize = option.resize || false;\n"
    txt += "        }\n"
    txt += "      window.addEventListener('resize',function()  {\n"
    txt += "          _me.redrawLines();\n"
    txt += "        //_me.Blines();\n"
    txt += "       //  _me.Listlines();\n"
    txt += "      })\n"
    txt += "      this.redrawLines = async function() {\n"
    txt += "        if (_lines.length == 0) return;\n"
    txt += "        _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "          for (let li = 0 ; li < _lines.length ;li++) {\n"
    txt += "            _me.connect(_lines[li])\n"
    txt += "            }\n"
    txt += "      };\n"
    txt += "      this.Splaylines = async function() {\n"
    txt += "        if (tree.length == 0) return;\n"
    txt += "        _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "        for (let source in tree) {\n"
    txt += "          let destination = tree[source];\n"
    txt += "          if(destination != 'null')\n"
    txt += "          _me.connect({left_node:source , right_node:destination+'treetop'})\n"
    txt += "          }\n"
    txt += "      };\n"
    txt += "      this.Listlines = function() {\n"
    txt += "        if (next.length == 0) return;\n"
    txt += "       _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "        for (let source in next) {\n"
    txt += "          let destination = next[source];\n"
    txt += "          if(destination != 'null')\n"
    txt += f"          _me.connect({{left_node:source , right_node:destination , col:{edge_color_starting} ,style:'dashed'}})\n"
    txt += "          }\n"
    txt += "      };\n"
    txt += "      this.Blines = function() {\n"
    txt += "        if (BTree.length == 0) return;\n"
    txt += "        _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "        for (let source in BTree) {\n"
    txt += "          let destination = BTree[source];\n"
    txt += "          if(destination != 'null')\n"
    txt += "          _me.connect({left_node:source , right_node:destination+'top',gtype:'UD' })\n"
    txt += "          }\n"
    txt += "      };\n"
    txt += "      return this;\n"
    txt += "    };\n"
    txt += "    var LineController = connect();\n"
    for edge in e:
        txt += "  LineController.drawLine({\n"
        txt += f"    left_node:'{edge[0]}',\n"
        txt += f"    right_node:'{edge[1]}',\n"
        txt += f"    label_node:'{edge[0]}-label',\n"
        txt += f"    col: {edge_color_starting},\n"
        txt += f"    width: 2,\n"
        txt += f"    text: {edge[3]},\n"
        txt += f"    style: 'solid',\n"
        txt += f"    gtype: '{edge[2]}',\n"
        txt += f"    ltype: '{edge[4]}',\n"
        txt += "  })\n"
        txt += f"  $( '.'+'node' ).draggable({{\n"
        txt += "  scroll: false,\n"
        txt += f"  drag: function(event, ui){{LineController.redrawLines();}}\n"
        txt += "  });\n"

    txt +=f"   var counters = Array(256).fill(0);\n"
    txt += f"  function change(id) {{\n"
    txt += f"       var colors = {node_color};\n"
    txt += "        var len = colors.length;\n"
    txt += f"       var e = document.getElementById(id);\n"
    txt += "        var index = id.charCodeAt(0);\n"
    txt += "        var counter = counters[index];\n"
    txt += f"       if (counter != len) {{\n"
    txt += f"           e.style.background = colors[counter];\n"
    txt += f"           counter = counter + 1;\n"
    txt += "        } \n "
    txt += "        else {\n"
    txt += f"           counter = 0;\n"
    txt += f"           e.style.background = colors[counter];\n"
    txt += "        }\n"
    txt += "        counters[index] = counter;\n"
    txt += "    }\n\n"
    txt += "    //Cambio orientamento archi\n"
    txt += "    function change_orientation(){\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            a = _lines[i].left_node;\n"
    txt += "            b = _lines[i].right_node;\n"
    txt += f"           if(document.getElementById(a).style.background != {initial_nodes_color} && document.getElementById(b).style.background != {initial_nodes_color}){{\n"
    txt += "                _lines[i].left_node = b;\n"
    txt += "                _lines[i].right_node = a;\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += "        this.redrawLines();\n"
    txt += "    }\n\n"
    txt += "    //Modalità attivata\n"
    txt += "    function path_color(){\n"
    txt += f"       var colors = {edge_color};\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            a = _lines[i].left_node;\n"
    txt += "            b = _lines[i].right_node;\n"
    txt += f"           if(document.getElementById(a).style.background != {initial_nodes_color} && document.getElementById(b).style.background != {initial_nodes_color}){{\n"
    txt += f"               index = colors.indexOf(_lines[i].col)\n"
    txt += f"               if(index == colors.length - 1)\n"
    txt += f"                    index = -1;\n"
    txt += f"               changecolor(a,b, colors[index + 1]);\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += f"       refresh_nodes({initial_nodes_color});\n"
    txt += "    }\n\n"
    txt += "    //Colora l'intero grafo\n"
    txt += "    function refresh_nodes(color){\n"
    txt += "        var divs = document.getElementsByClassName('node');\n"
    txt += "        for(i=0; i<Object.keys(divs).length; i++){\n"
    txt += "            index = divs[i].id.charCodeAt(0);\n"
    txt += "            counters[index] = 0;\n"
    txt += "            divs[i].style.background = color;\n"
    txt += "        }\n"
    txt += "    }\n\n"
    txt += "    //Colora l'intero grafo\n"
    txt += "    function refresh_edges(color){\n"
    txt += "        for(i=1; i < Object.keys(_lines).length; i++){\n"
    txt += "            a = _lines[i].left_node;\n"
    txt += "            b = _lines[i].right_node;\n"
    txt += "            changecolor(a,b, color);\n"
    txt += "        }\n"
    txt += "    }\n\n"
    txt += "    function send_output(status){\n"
    txt += "        var output = new Object();\n"
    txt += "        output[status] =  new Object();\n"
    txt += "        var nodes = document.getElementsByClassName('node');\n"
    txt += "        output[status].n = new Array();\n"
    txt += "        //Aggiungo nodi all'output\n"
    txt += "        for(i=0; i<Object.keys(nodes).length; i++){\n"
    txt += "            var node = new Object();\n"
    txt += "            node.id = nodes[i].id;\n"
    txt += "            node.color = nodes[i].style.background;\n"
    txt += "            output[status].n.push(node);\n"
    txt += "        }\n"
    txt += "        output[status].m = new Array();\n"
    txt += "        //Aggiungo archi all'output\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            var edge = new Object();\n"
    txt += "            edge.left = _lines[i].left_node;\n"
    txt += "            edge.right = _lines[i].right_node;\n"
    txt += "            edge.color = _lines[i].col;\n"
    txt += "            edge.orientation = _lines[i].gtype;\n"
    txt += "            edge.value = _lines[i].text;\n"
    txt += "            output[status].m.push(edge);\n"
    txt += "           }\n"
    txt += "        var jsonString = JSON.stringify(output, null, '\t');\n"
    txt += "        window.parent.postMessage(jsonString, '*');\n"
    txt += f"       refresh_edges({edge_color_starting});\n"
    txt += f"       refresh_nodes({initial_nodes_color});\n"
    txt += "    }\n\n"
    txt += "    function get_colored_nodes(status){\n"
    txt += "        var output = new Object();\n"
    txt += "        output[status] =  new Array();\n"
    txt += "        var nodes = document.getElementsByClassName('node');\n"
    txt += "        //Aggiungo nodi all'output\n"
    txt += "        for(i=0; i<Object.keys(nodes).length; i++){\n"
    txt += f"            if(nodes[i].style.background != {initial_nodes_color}){{\n"
    txt += "                var node = new Object();\n"
    txt += "                node = nodes[i].id;\n"
    txt += "                output[status].push(node);\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += "        var jsonString = JSON.stringify(output, null);\n"
    txt += "        window.parent.postMessage(jsonString, '*');\n"
    txt += "    }\n\n"
    txt += "    function get_all_nodes(status){\n"
    txt += "        var output = new Object();\n"
    txt += "        output[status] =  new Object();\n"
    txt += "        var nodes = document.getElementsByClassName('node');\n"
    txt += "        //Aggiungo nodi all'output\n"
    txt += "        for(i=0; i < Object.keys(nodes).length; i++){\n"
    txt += "            if(output[status][nodes[i].style.background] == undefined)\n"
    txt += "                output[status][nodes[i].style.background] = new Array();"
    txt += "            output[status][nodes[i].style.background].push(nodes[i].id);\n"
    txt += "        }\n"
    txt += "        var jsonString = JSON.stringify(output, null);\n"
    txt += "        window.parent.postMessage(jsonString, '*');\n"
    txt += "    }\n\n"
    txt += "    function get_path(status){\n"
    txt += "        var output = new Object();\n"
    txt += "        output[status] =  new Array();\n"
    txt += "        //Aggiungo archi all'output\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += f"           if(_lines[i].col != {edge_color_starting})\n"
    txt += "                //Aggiungere qui il peso _lines[i].text per stampare il peso (si può creare oggetto edge come in funzione send)\n"
    txt += "                output[status].push(_lines[i].left_node + '_' + _lines[i].right_node);\n"
    txt +=  "       }\n"
    txt += "    var jsonString = JSON.stringify(output, null);\n"
    txt += "    window.parent.postMessage(jsonString, '*');\n"
    txt += f"    refresh_edges({edge_color_starting});\n"
    txt += "    }\n\n"
    txt += "    function get_orientation_edge(status){\n"
    txt += "        var output = new Object();\n"
    txt += "        output[status] =  new Object();\n"
    txt += "        //Aggiungo archi all'output\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            if(output[status][_lines[i].gtype] == undefined)\n"
    txt += "                output[status][_lines[i].gtype] = new Array();"
    txt += "            output[status][_lines[i].gtype].push(_lines[i].left_node + '_' + _lines[i].right_node);\n"
    txt += "        }\n"
    txt += "    var jsonString = JSON.stringify(output, null);\n"
    txt += "    window.parent.postMessage(jsonString, '*');\n"
    txt += "    }\n\n"
    txt += "    function get_colored_edges(status){\n"
    txt += "        var output = new Object();\n"
    txt += "        output[status] =  new Object();\n"
    txt += "        //Aggiungo archi all'output\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            if(output[status][_lines[i].col] == undefined)\n"
    txt += "                output[status][_lines[i].col] = new Array();"
    txt += "            output[status][_lines[i].col].push(_lines[i].left_node + '_' + _lines[i].right_node);\n"
    txt += "        }\n"
    txt += "    var jsonString = JSON.stringify(output, null);\n"
    txt += "    window.parent.postMessage(jsonString, '*');\n"
    txt += "    }\n\n"
    txt += "    function change_nodetag(a, b){\n"
    txt += "        var nodes = document.getElementsByClassName('node');\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            if(_lines[i].left_node == a){\n"
    txt += "                id = linemap[`${_lines[i].left_node}${_lines[i].right_node}`];\n"
    txt += "                _lines[i].left_node = b;\n"
    txt += "                linemap[`${_lines[i].left_node}${_lines[i].right_node}`] = id;\n"
    txt += "             }\n"
    txt += "            else if (_lines[i].right_node == a){\n"
    txt += "                id = linemap[`${_lines[i].left_node}${_lines[i].right_node}`];\n"
    txt += "                _lines[i].right_node = b;\n"
    txt += "                linemap[`${_lines[i].left_node}${_lines[i].right_node}`] = id;\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += "        for(i=0; i<Object.keys(nodes).length; i++){\n"
    txt += "            if(nodes[i].id == a){\n"
    txt += "                inner = nodes[i].innerHTML;\n"
    txt += '                var tag = document.getElementById(a+"-label-char");\n'
    txt += '                tag.id = b+"-label-char";\n'
    txt += "                tag.innerHTML = b;\n"
    txt += '                var label = document.getElementById(a+"-label");\n'
    txt += '                label.id = b+"-label";\n'
    txt += "                nodes[i].id = b;\n"
    txt += "                //nodes[i].innerHTML = b;\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += "    }\n"
    txt += "    //Comunicazione parent-iframe\n"
    txt += "    window.onmessage = function(e){\n"
    txt += "        if (e.data == 'changecolor')\n"
    txt += "            path_color();\n"
    txt += "        if (e.data == 'changeorientation')\n"
    txt += "            change_orientation();\n"
    txt += "        if (String(e.data).includes('changetag')){\n"
    txt += "            a = String(e.data).split('.')[1].split('.')[0];\n"
    txt += "            b = String(e.data).split('.')[2];\n"
    txt += "            change_nodetag(a, b);\n"
    txt += "        }\n"
    txt += "        if (String(e.data).split('.')[1] == 'edgeset')\n"
    txt += "            get_path(String(e.data).split('.')[0]);\n"
    txt += "        if (String(e.data).split('.')[1] == 'nodeset')\n"
    txt += "            get_colored_nodes(String(e.data).split('.')[0]);\n"
    txt += "        if (String(e.data).split('.')[1] == 'orientation')\n"
    txt += "            get_orientation_edge(String(e.data).split('.')[0]);\n"
    txt += "        if (String(e.data).split('.')[1] == 'edgecol')\n"
    txt += "            get_colored_edges(String(e.data).split('.')[0]);\n"
    txt += "        if (String(e.data).split('.')[1] == 'nodecol')\n"
    txt += "            get_all_nodes(String(e.data).split('.')[0]);\n"
    txt += "        if (String(e.data).split('.')[1] == 'send')\n"
    txt += "            send_output(String(e.data).split('.')[0]);\n"
    txt += "    };\n"
    txt += "</script>"
    with open(os.path.join(os.getcwd(),"esame","templates","esame","graph.html"),"r") as stream:
        html = "".join(stream.readlines())
        t = html.replace("GRAFO",txt)

    f = open(os.path.join(TEMPLATES_DIRECTORY,"grafo_template.html"),"w")
    f.write(t)
    f.close()
